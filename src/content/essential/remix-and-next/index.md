---
title: "The choice of framework between remix and next"
description: "Lorem ipsum dolor sit amet"
pubDate: "Jul 08 2024"
heroImage: "/typescript.jpg"
---

<p>The choice of a framework isn’t merely a technical decision, it’s a commitment to a trajectory. Both Next.js and Remix are robust frameworks that cater to modern web development needs, but they differ in their approach to <strong>routing</strong>, <strong>data fetching</strong>, and <strong>performance optimization</strong>. As fault lines get wider in terms of upcoming features and the ecosystem surrounding each framework, the choice you make today will affect your ability to maintain, resolve bugs, and find third-party integrations tomorrow.</p><p></p><p>Let\'s delve into a comparative analysis of the key features of both frameworks so you have a solid foundation for making an informed decision that best suits your project requirements.</p><h2 id="1.-routing-and-navigation">1. Routing and Navigation</h2><p>Next.js uses a <strong>file-based</strong> routing system where each file in the “pages” directory becomes a route. For example, if you have a file called <code>index.js</code> in the <code>pages</code> directory, it will be mapped to the <strong><code>/</code></strong> route. So to create a new route in Next.js, simply create a new file in the <code>pages</code> directory.</p><p>For example, if you want to create a new route called <code>/about</code>, you simply create a new file called <code>about.js</code> in the pages directory:</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AboutPage</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>About Us<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;}<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AboutPage;</code></pre><p>Remix, on the other hand, uses a <strong>route-centric</strong> approach, meaning routes are explicitly mentioned in the configuration file, generally <code>remix.config.js</code>. This configuration file maps the URLs to route modules. Let’s say you have a Remix project with the following route modules:</p><pre><code class="hljs javascript">src/├── routes/│ ├── index.tsx <span class="hljs-comment">// Represents the root route ("/")</span>│ ├── about.tsx <span class="hljs-comment">// Represents the "/about" route</span>│ └── contact.tsx <span class="hljs-comment">// Represents the "/contact" route</span></code></pre><p>To explicitly define routes and map URLs to these route modules, you would create or modify your <code>remix.config.js</code> file like below:</p><pre><code class="hljs javascript"><span class="hljs-comment">// remix.config.js</span><span class="hljs-built_in">module</span>.exports = { <span class="hljs-comment">// ...other configuration options...</span> <span class="hljs-attr">routes</span>: { <span class="hljs-comment">// Define the root route ("/") and specify the entry point</span> <span class="hljs-string">\'/\'</span>: <span class="hljs-string">\'src/routes/index.tsx\'</span>, <span class="hljs-comment">// Define the "/about" route and specify the entry point</span> <span class="hljs-string">\'/about\'</span>: <span class="hljs-string">\'src/routes/about.tsx\'</span>, <span class="hljs-comment">// Define the "/contact" route and specify the entry point</span> <span class="hljs-string">\'/contact\'</span>: <span class="hljs-string">\'src/routes/contact.tsx\'</span>, <span class="hljs-comment">// Add more routes as needed...</span> },};</code></pre><p>The choice between Next.js and Remix boils down to a preference for simplicity versus explicit configuration. Next.js adopts a file-based routing system, making the creation of new routes as straightforward as adding a new file in the <code>pages</code> directory. This approach is intuitive and requires minimal setup, making it a great choice for developers who prefer a straightforward, convention-over-configuration routing system.</p><p>On the flip side, Remix employs a route-centric approach where routes are explicitly defined in a configuration file. This setup provides a clear overview of all routes and their corresponding entry points in one place, allowing for more control and organization, especially in larger or more complex applications. It\'s a solid choice for developers who prefer having an explicit routing configuration and don\'t mind the additional setup for the sake of clarity and control.</p><p>The decision hinges on whether you value ease and simplicity or explicit organization and control when managing the routing in your web applications.</p><h2 id="2.-data-loading-and-fetching">2. Data Loading and Fetching</h2><p>In Next.js, you can use a variety of techniques to fetch data, depending on your needs. For example, you can use:</p><ol><li><code>getServerSideProps</code> to fetch data on the server and render it on the server. It is a good option for dynamic data that needs to be updated frequently.</li><li><code>getStaticProps</code> to fetch data on the server and render it statically. It is a good option for static data that doesn\'t change often.</li><li><code>getInitialProps</code> to fetch data on the server and pass it to the client. It is a good option for data that needs to be fetched on the server but can be updated on the client.</li></ol><p>Client-side data fetching in <code>Next.js</code> is typically done with standard React <code>useEffect</code> or fetch calls.</p><p>For instance, using <code>getStaticProps</code> for server-side rendering:</p><pre><code class="hljs javascript"><span class="hljs-comment">// pages/index.js</span><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HomePage</span>(<span class="hljs-params">{ message }</span>) </span>{ <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;}<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStaticProps</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">\'https://api.example/data\'</span>); <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json(); <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { <span class="hljs-attr">message</span>: data.message, }, };}<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> HomePage;</code></pre><p>In Remix, the concept of loaders is used to fetch data for a route. These can be defined for both server-side and client-side data fetching. This approach provides a unified way to manage data loading across our application.</p><pre><code class="hljs javascript"><span class="hljs-comment">// routes/about.js</span><span class="hljs-keyword">import</span> { json, LoaderFunction } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@remix-run/node\'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> loader: LoaderFunction = <span class="hljs-keyword">async</span> ({ request }) =&gt; { <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">\'https://api.example.com/about\'</span>); <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json(); <span class="hljs-keyword">return</span> json({ <span class="hljs-attr">message</span>: data.message });};<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">About</span>(<span class="hljs-params">{ message }</span>) </span>{ <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;}</code></pre><p>For someone new to both frameworks, learning three different data fetching methods in Next.js is a steeper learning curve compared to learning the single loader concept in Remix.</p><p>The other thing to consider is since data fetching methods in Next.js are placed alongside the page components, this can lead to large files if the data fetching logic is complex. Remix encourages placing loaders in a separate file or alongside the route module, which can lead to better organization, especially in applications with complex data fetching logic.</p><h2 id="3.-performance-optimization">3. Performance Optimization</h2><p>While both frameworks are engineered for high performance, Remix offers better dynamic content delivery, faster build times, and a more straightforward approach to handling data. On the other hand, if your project has a strong emphasis on delivering static content efficiently, and you’re already familiar with Next.js, there’s no reason to move away from it.</p><p>Remix’s edge is in serving dynamic content. It\'s designed to deliver fast user experiences even on slow networks, automatically handling errors, interruptions, and race conditions which Next.js doesn\'t handle out of the box.</p><p>Next.js encourages the use of client-side JavaScript for serving dynamic content and requires it for data mutations. On the contrary, Remix doesn\'t rely on client-side JavaScript for these tasks, leading to faster interactions and less data over-fetching.</p><p>As projects scale, Next.js build times increase linearly with your data, which could slow down the development process. Remix, though, boasts nearly instant build times that are decoupled from data, making it a more scalable choice for larger projects.</p><h2 id="choose-next.js-for-its-mature-ecosystem,-remix-for-its-dynamic-flexibility">Choose Next.js for its Mature Ecosystem, Remix for its Dynamic Flexibility</h2><figure style="margin-bottom: 30px;"> <img decoding="async" src="https://cdn.rollbar.com/wp-content/uploads/2023/10/next-remix-npm-trends.webp" alt="Next.js vs Remix npm trends" style="box-shadow: none; border-radius: 0;"><figcaption style="text-align: center;"><em>Next.js is more popular than Remix, but Remix is a compelling choice for teams looking to deliver fast user experiences and handle data efficiently.</em></figcaption></figure><p>Next.js is a well-established framework with a larger community and ecosystem than Remix, a significant advantage when looking for solutions to problems, plugins, or integrations.</p><p>That said, Remix was clearly designed to improve developer productivity with its route-centric development and fine-grained control over data loading and navigation. It provides a performance edge especially in applications with complex data requirements.</p><p>For a project that serves a vast amount of static content like an e-commerce site’s product pages, category pages, and blog posts, Next.js would be a wise choice due to its strong support for static site generation and many integrations.</p><p>However, if you’re building something like a real-time dashboard that must handle dynamic data efficiently, provide fast user experiences even on slow networks, and allow for flexible routing to manage the complex navigation requirements of the dashboard, Remix would be a more fitting choice. The route-centric development and unified data fetching method provided by Remix would allow for complex routing scenarios and efficient handling of dynamic data.</p><p>In the end, both frameworks are robust and capable, and your choice will ultimately depend on your project\'s long-term vision and the development experience you seek to achieve.</p><h2 id="track,-analyze-and-manage-errors-with-rollbar">Track, Analyze and Manage Errors With Rollbar</h2><p>No matter which framework you gravitate towards, ensuring the smooth operation of your app is paramount. Unforeseen errors can be a thorn in your project, disrupting user experience and hindering your app\'s success. With Rollbar, you can stay a step ahead, tracking and analyzing errors in your Next.js or Remix apps in real-time. Don\'t let unexpected issues slow you down. Make the smart move—<a href="https://rollbar.com/signup/">integrate Rollbar into your workflow today</a>, and ensure that your app is always performing at its peak.</p><p><strong>See our other blog post comparing frameworks</strong></p><ul><li><a href="https://rollbar.com/blog/react-js-vs-next-js/">React.js vs. Next.js</a></li><li><a href="https://rollbar.com/blog/next-js-vs-react-performance/">React.js vs. Next Performance</a></li><li><a href="https://rollbar.com/blog/nextjs-vs-vitejs/">Next.js vs. Vite.js</a></li><li><a href="https://rollbar.com/blog/angular-vs-react/">Angular vs. React</a></li></ul><style>#tableOfContents { position: sticky; top: 20px; max-width: 300px; margin-left: 20px; border-left: 3px solid #333; padding-left: 10px;}</p><p>#tableOfContents p { font-weight: 600; font-size: 18px; line-height: 22px; margin-bottom: 16px;}</p><p>#tableOfContents a { display: block; margin: 5px 0; text-decoration: none; color: #007BFF; cursor: pointer; transition: color 0.3s ease;}</p><p>#tableOfContents a:hover { color: #0056b3;}</p><p>body { scroll-behavior: smooth;}</style>
