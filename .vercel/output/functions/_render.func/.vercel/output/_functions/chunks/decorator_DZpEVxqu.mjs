import { a as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_CrkWirIh.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<h3 id=\"introduction\">Introduction</h3>\n<ul>\n<li>\n<p>With the introduction of <strong>Classes</strong> in <strong>Typescript</strong> and <strong>ES6</strong>,\nthere now exits certain (chắc chắn) scenarios( kịch bản) that require additional feature to support annotating or modifying classes and class members. Decorator provide a way to (1 cách để ) add both annotation and a meta-programming syntax for class declarations and members.</p>\n</li>\n<li>\n<p><strong>Node</strong>: To enable experimental(thực nghiệm) support for decorator,\nyou must enable the <strong>experimentalDecorators</strong> compiler option either on <strong>tsconfig.json</strong>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>tsc --target ES5 --experimentalDecorators</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<ul>\n<li>compiler tsconfig.json:</li>\n</ul>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>{</span></span>\n<span class=\"line\"><span>\"compilerOptions\": {</span></span>\n<span class=\"line\"><span>  \"target\": \"ES5\",</span></span>\n<span class=\"line\"><span>  \"experimentalDecorators\": true</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"decorators\">Decorators</h3>\n<ul>\n<li>\n<p>A <strong>decorator</strong> kind of declaration that can be attached to a <strong>class declaration</strong>, <strong>method</strong>,<strong>accessor</strong>(người tiếp cận), <strong>property</strong> or <strong>parameter</strong>. Decorator use the form <strong>@expression</strong>, where <strong>expression</strong> must evaluate to a function that will be called at runtime with information about the decorated declaration.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>function sealed(target) {</span></span>\n<span class=\"line\"><span>  // do something with 'target' ...</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"decorator-factories\">Decorator Factories</h3>\n<ul>\n<li>\n<p><strong>A Decorator Factory</strong> is simply a function that returns the expression that will be called by the decorator at runtime.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>function color(value: string) {</span></span>\n<span class=\"line\"><span>  // this is the decorator factory, it sets up</span></span>\n<span class=\"line\"><span>  // the returned decorator function</span></span>\n<span class=\"line\"><span>  return function (target) {</span></span>\n<span class=\"line\"><span>    // this is the decorator</span></span>\n<span class=\"line\"><span>    // do something with 'target' and 'value'...</span></span>\n<span class=\"line\"><span>  };</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"decorator-composition\">Decorator Composition</h3>\n<ul>\n<li>\n<p>Multiple decorators can be applied to a declaration, for example on a single line:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>@f @g x</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n</li>\n<li>\n<p>On multiple lines:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>function first() {</span></span>\n<span class=\"line\"><span>  console.log(\"first(): factory evaluated\");</span></span>\n<span class=\"line\"><span>  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {</span></span>\n<span class=\"line\"><span>    console.log(\"first(): called\");</span></span>\n<span class=\"line\"><span>  };</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>function second() {</span></span>\n<span class=\"line\"><span>  console.log(\"second(): factory evaluated\");</span></span>\n<span class=\"line\"><span>  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {</span></span>\n<span class=\"line\"><span>    console.log(\"second(): called\");</span></span>\n<span class=\"line\"><span>  };</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>class ExampleClass {</span></span>\n<span class=\"line\"><span>  @first()</span></span>\n<span class=\"line\"><span>  @second()</span></span>\n<span class=\"line\"><span>  method() {}</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>// Which would print this output to the console:</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>first(): factory evaluated</span></span>\n<span class=\"line\"><span>second(): factory evaluated</span></span>\n<span class=\"line\"><span>second(): called</span></span>\n<span class=\"line\"><span>first(): called</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n</li>\n<li>\n<p>When multiple decorators apply to a single declaration, their evaluation is similar to function composition in mathematics. In this model, when composing functions f and g, the resulting composite (f ∘ g)(x) is equivalent to f(g(x)).</p>\n</li>\n<li>\n<p>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</p>\n<ul>\n<li>The expressions for each decorator are evaluated top-to-bottom.</li>\n<li>The results are then called as functions from bottom-to-top.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"class-decorators\">Class Decorators</h3>\n<ul>\n<li>\n<p><strong>A Decorator</strong> is declared just before a function declaration. The class decorator is applied to the constructor of the class and can be used modify, observe, or replace a class definition(định nghĩa). <strong>A class decorator</strong> cannot be used in a declaration file, or in many other ambient(xung quanh) context(such as on declare class).</p>\n</li>\n<li>\n<p>if the class decorator returns a values, it will replace the class declaration with the provided constructor function.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>@sealed</span></span>\n<span class=\"line\"><span>class BugReport {</span></span>\n<span class=\"line\"><span>  type = \"report\";</span></span>\n<span class=\"line\"><span>  //title= string;</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>  constructor(t: string) {</span></span>\n<span class=\"line\"><span>    this.title = t;</span></span>\n<span class=\"line\"><span>  }</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span>function sealed(constructor: Function) {</span></span>\n<span class=\"line\"><span>  Object.seal(constructor);</span></span>\n<span class=\"line\"><span>  Object.seal(constructor.prototype);</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"note-the-decorator-does-not-change-the-typescript-type\">Note: the decorator <em>does not</em> change the TypeScript type</h3>";

				const frontmatter = {"title":"Typescript","description":"Lorem ipsum dolor sit amet","pubDate":"Jul 08 2022","heroImage":"/typescript.jpg"};
				const file = "C:/Users/kiet.huynh/Documents/essential-programming-concepts-master/essential-programming-concepts-master/src/content/essential/typescript/decorator.md";
				const url = undefined;
				function rawContent() {
					return "\n### Introduction\n\n- With the introduction of **Classes** in **Typescript** and **ES6**,\n  there now exits certain (chắc chắn) scenarios( kịch bản) that require additional feature to support annotating or modifying classes and class members. Decorator provide a way to (1 cách để ) add both annotation and a meta-programming syntax for class declarations and members.\n\n- **Node**: To enable experimental(thực nghiệm) support for decorator,\n  you must enable the **experimentalDecorators** compiler option either on **tsconfig.json**:\n\n  ```\n  tsc --target ES5 --experimentalDecorators\n  ```\n\n  - compiler tsconfig.json:\n\n  ```\n  {\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n  }\n  ```\n\n### Decorators\n\n- A **decorator** kind of declaration that can be attached to a **class declaration**, **method**,**accessor**(người tiếp cận), **property** or **parameter**. Decorator use the form **@expression**, where **expression** must evaluate to a function that will be called at runtime with information about the decorated declaration.\n\n  ```\n  function sealed(target) {\n    // do something with 'target' ...\n  }\n  ```\n\n### Decorator Factories\n\n- **A Decorator Factory** is simply a function that returns the expression that will be called by the decorator at runtime.\n\n  ```\n  function color(value: string) {\n    // this is the decorator factory, it sets up\n    // the returned decorator function\n    return function (target) {\n      // this is the decorator\n      // do something with 'target' and 'value'...\n    };\n  }\n  ```\n\n### Decorator Composition\n\n- Multiple decorators can be applied to a declaration, for example on a single line:\n\n  ```\n  @f @g x\n  ```\n\n- On multiple lines:\n\n  ```\n  function first() {\n    console.log(\"first(): factory evaluated\");\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n      console.log(\"first(): called\");\n    };\n  }\n\n  function second() {\n    console.log(\"second(): factory evaluated\");\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n      console.log(\"second(): called\");\n    };\n  }\n\n  class ExampleClass {\n    @first()\n    @second()\n    method() {}\n  }\n\n  // Which would print this output to the console:\n\n  first(): factory evaluated\n  second(): factory evaluated\n  second(): called\n  first(): called\n  ```\n\n- When multiple decorators apply to a single declaration, their evaluation is similar to function composition in mathematics. In this model, when composing functions f and g, the resulting composite (f ∘ g)(x) is equivalent to f(g(x)).\n\n- As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:\n\n  - The expressions for each decorator are evaluated top-to-bottom.\n  - The results are then called as functions from bottom-to-top.\n\n### Class Decorators\n\n- **A Decorator** is declared just before a function declaration. The class decorator is applied to the constructor of the class and can be used modify, observe, or replace a class definition(định nghĩa). **A class decorator** cannot be used in a declaration file, or in many other ambient(xung quanh) context(such as on declare class).\n\n- if the class decorator returns a values, it will replace the class declaration with the provided constructor function.\n\n  ```\n  @sealed\n  class BugReport {\n    type = \"report\";\n    //title= string;\n\n    constructor(t: string) {\n      this.title = t;\n    }\n  }\n  function sealed(constructor: Function) {\n    Object.seal(constructor);\n    Object.seal(constructor.prototype);\n  }\n\n  ```\n\n### Note: the decorator _does not_ change the TypeScript type\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":3,"slug":"introduction","text":"Introduction"},{"depth":3,"slug":"decorators","text":"Decorators"},{"depth":3,"slug":"decorator-factories","text":"Decorator Factories"},{"depth":3,"slug":"decorator-composition","text":"Decorator Composition"},{"depth":3,"slug":"class-decorators","text":"Class Decorators"},{"depth":3,"slug":"note-the-decorator-does-not-change-the-typescript-type","text":"Note: the decorator does not change the TypeScript type"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
